<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Home Measurement Dashboard</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/webjars/bootstrap/4.3.1/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/webjars/chartjs/2.9.3/Chart.min.css" />
    <script src="/webjars/jquery/3.4.1/jquery.min.js"></script>
    <script src="/webjars/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <script src="/webjars/momentjs/2.24.0/min/moment.min.js"></script>
    <script src="/webjars/chartjs/2.9.3/Chart.min.js"></script>
</head>
<body>
<!--/*@thymesVar id="sensor" type="java.util.Map.Entry"*/-->
<!--/*@thymesVar id="sensorrecord" type="eu.seatter.homemeasurement.collector.model.SensorRecord"*/-->
    <div class="container-fluid" style="margin-top: 20px">
        <div class="row">
            <div class="col-md-6 col-md-offset-3">
                <div class="panel panel-primary">

                    <div class="panel-heading">
                        <h1 class="panel-title">Sensor Measurements</h1>
                    </div>
                    <div class="panel-body">
                        <div class="panel-content text-center" th:if="${not #lists.isEmpty(allMeasurements)}">
                            <canvas id="measurementChart" class="chart"></canvas>
                        </div>
<!--                        <div class="panel-footer">A simple Line Chart with basic settings</div>-->
                    </div>
                </div>
                <div class="panel panel-primary">

                    <div class="panel-heading">
                        <h1 class="panel-title">Sensor Measurements</h1>
                    </div>
                    <div class="panel-body">
                        <div class="table-responsive" th:if="${not #lists.isEmpty(allMeasurements)}">
                            <table class="table table-hover ">
                                <thead class="thead-inverse">
                                <tr>
                                    <th>#</th>
                                    <th>Name</th>
                                    <th>SensorID</th>
                                    <th>Time</th>
                                    <th>value</th>
                                </tr>
                                </thead>
                                <tbody>
                                    <th:block th:each="sensor : ${allMeasurements}">
<!--                                        <tr>-->
                                            <tr th:each="sensorrecord, iStat : ${sensor.value}" th:class="${sensorrecord.value > sensorrecord.low_threshold}? 'table-light' : 'table-danger'">
                                                <td th:text="${iStat.index + 1}">index missing</td>
                                                <td th:text="${sensorrecord.title}">title missing</td>
                                                <td th:text="${sensorrecord.sensorid}">sensorid missing</td>
                                                <td th:text="${#temporals.format(sensorrecord.measureTimeUTC, 'yyyy-MM-dd HH:mm:ss')}">time missing</td>
                                                <td th:text="${sensorrecord.value + ' ' + sensorrecord.measurementUnit.toString()}">value missing</td>
                                            </tr>
<!--                                        </tr>-->
                                    </th:block>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>
</body>
<script th:inline="javascript">
    let measurements = /*[[${allMeasurements}]]*/ 'default';
    console.log(measurements);
    let ctx = document.getElementById('measurementChart').getContext('2d');
    let chart = new Chart(ctx, {
        type: 'line',
        options: {
            responsive: true,
            hoverMode: 'index',
            stacked: false,
            scales: {
                yAxes: [{
                    type: 'linear', // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance
                    display: true,
                    position: 'left',
                    id: 'y-axis-1',
                    reverse: true,
                    scaleLabel: {
                        display:     true,
                        labelString: 'Temp(C)'
                    },
                    gridLines: {
                        drawOnChartArea: false, // only want the grid lines for one axis to show up
                    }
                }],
                xAxes: [{
                    scaleLabel: {
                        display:     true,
                        labelString: 'Time'
                    },
                    ticks: {
                        reverse: true,
                        beginAtZero: true
                    }
                }]
            }
        }
    });

    let dataSetColourScheme = [ {backgroundColor: 'rgb(255, 200, 132)', borderColor: 'rgb(255, 200, 132)', fill: false},
                                {backgroundColor: 'rgb(100, 99, 132)', borderColor: 'rgb(100, 99, 132)',fill: false}]

    let labelValues = Object.values(measurements)[0].map(sr => sr.measureTimeUTC);
    chart.data.labels = labelValues;
    let dataSetIndex = 0
    Object.keys(measurements).forEach(function (sensorId) {
        let sensorData = measurements[sensorId]
        let sensorTitle = sensorData[0].title
        let measurementValues = sensorData.map(sr => sr.value)
        console.log(measurementValues)
        if (measurementValues) {
            let dataSet = {
                label: sensorTitle,
                backgroundColor: dataSetColourScheme[dataSetIndex].backgroundColor,
                borderColor: dataSetColourScheme[dataSetIndex].borderColor,
                fill: dataSetColourScheme[dataSetIndex].fill,
                data: measurementValues
            }
            chart.data.datasets.push(dataSet)
        }
        dataSetIndex ++
    })
    chart.update()

    chart.render();
</script>